{"ast":null,"code":"var _jsxFileName = \"/Users/luked/Documents/slnsw/dxlab-art-index/components/TextTruncate/TextTruncate.tsx\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport PropTypes from 'prop-types'; // import Button from '../Button';\n\nimport { isInViewport } from '../../lib/is-in-viewport'; // import { useUniqueId } from '../../lib/hooks';\n\nimport css from './TextTruncate.module.scss';\n\n/**\n * Truncates text within props.children\n * Can accept multiple tags, strings or dangerouslySetInnerHTML\n * If using multiple tags, the first tag is used to display the truncated text.\n * Copied from CEP\n * TODO: Consider publishing as own component\n * TODO: Add tests from CEP\n */\nconst TextTruncate = ({\n  className,\n  children,\n  limit = 100,\n  ellipsisChars = '…',\n  showButton = true,\n  shouldStripHtml = false // onChange,\n\n}) => {\n  const [isActive, setActive] = React.useState(true);\n  React.useEffect(() => {\n    setActive(true);\n  }, [children]); // const idScope = React.useRef(useUniqueId(`TextTruncate--`)).current;\n\n  const textTopMarkerEl = React.useRef(null);\n\n  if (children === undefined) {\n    return null;\n  } // Work in progress\n  // if (typeof onChange === 'function') {\n  //   if (children.length > limit) {\n  //     onChange('more');\n  //   } else {\n  //     onChange('less');\n  //   }\n  // }\n  // Assign firstChildrenType\n\n\n  let firstChildrenType; // Determine which initial element to use when truncate is active\n\n  if (typeof children === 'string') {\n    firstChildrenType = 'string';\n  } else if (Array.isArray(children)) {\n    if (children[0].props.dangerouslySetInnerHTML &&\n    /* eslint-disable no-underscore-dangle */\n    children[0].props.dangerouslySetInnerHTML.__html) {\n      firstChildrenType = 'html';\n    } else {\n      firstChildrenType = 'tags';\n    }\n  } else if (React.Children.only(children)) {\n    if (children.props.dangerouslySetInnerHTML &&\n    /* eslint-disable no-underscore-dangle */\n    children.props.dangerouslySetInnerHTML.__html\n    /* eslint-enable no-underscore-dangle */\n    ) {\n        firstChildrenType = 'html';\n      } else {\n      firstChildrenType = 'tag';\n    }\n  } // Extract text\n\n\n  const text = React.Children.map(children, child => {\n    let childText;\n\n    if (typeof child === 'string') {\n      childText = child;\n    } else if (child.props.dangerouslySetInnerHTML &&\n    /* eslint-disable no-underscore-dangle */\n    child.props.dangerouslySetInnerHTML.__html) {\n      childText = child.props.dangerouslySetInnerHTML.__html;\n      /* eslint-enable no-underscore-dangle */\n    } else {\n      childText = child.props.children;\n    }\n\n    return childText;\n  }).join(' '); // Don't really want to count the HTML tags in the length\n\n  const isTextOverLimit = stripHtml(text).length > limit;\n  let result;\n\n  if (isTextOverLimit && isActive) {\n    const strippedText = shouldStripHtml ? stripHtml(text) : text; // const truncatedText = `${strippedText\n    //   .slice(0, limit)\n    //   .trimRight()}${ellipsisChars}`;\n\n    const truncatedText = truncateNicely(strippedText, limit, ellipsisChars); // Assign processed text depending on firstChildrenType\n\n    if (firstChildrenType === 'string') {\n      result = truncatedText;\n    } else if (firstChildrenType === 'html') {\n      const newHtmlChild = children.length > 0 ? children[0] : children;\n      result = /*#__PURE__*/React.cloneElement(newHtmlChild, shouldStripHtml ? {\n        // dangerouslySetInnerHTML: {\n        //   __html: truncatedText,\n        // },\n        children: truncatedText,\n        dangerouslySetInnerHTML: undefined\n      } : {\n        dangerouslySetInnerHTML: {\n          __html: truncatedText\n        }\n      });\n    } else if (firstChildrenType === 'tags') {\n      result = /*#__PURE__*/React.cloneElement(children[0], {\n        children: truncatedText\n      });\n    } else if (firstChildrenType === 'tag') {\n      result = /*#__PURE__*/React.cloneElement(children, {\n        children: truncatedText\n      });\n    }\n  } else {\n    result = children;\n  }\n\n  return __jsx(React.Fragment, null, __jsx(\"span\", {\n    // id={idScope}\n    ref: textTopMarkerEl,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }\n  }), result, showButton && isTextOverLimit ? __jsx(\"button\", {\n    className: [css.button, className].join(' '),\n    \"data-testid\": \"showMoreButton\",\n    \"aria-expanded\": !isActive // aria-controls={idScope}\n    ,\n    onClick: () => {\n      // Scroll back up to top of text if truncate is active and marker element is out of viewport\n      if (!isActive && !isInViewport(textTopMarkerEl.current)) {\n        textTopMarkerEl.current.scrollIntoView();\n      }\n\n      setActive(!isActive);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 9\n    }\n  }, isActive ? 'Read more' : 'Read less') : null);\n};\n\nfunction stripHtml(text) {\n  return text.replace(/(<([^>]+)>)/gi, '');\n}\n\nfunction truncateNicely(text, limit, endChar) {\n  // console.log(text);\n  // Writen by LukeD Apr/May 2020\n  // NOTE: uses generateClosingTag() function below.\n  // Function is passed a text string to be truncated to 'limit' chars long\n  // But it may contain nested HTML <tags> which we don't want to truncate in\n  // the middle of leaving this: <tag... (we also don't really want to count\n  // them as they don't generally contribute to the length of text rendered.)\n  // Also we want to ensure the correct closing tags exit after the truncation\n  // so the returned text is valid HTML.\n  const splitByTags = text.split(/(<[^>]+>)/gi); // The above returns an array something like:\n  // [ 'text', 'tag', 'text', 'tag', 'text', 'tag', 'text', 'tag', 'text' ]\n\n  const stack = []; // place to remember opened tags that might need to closed after truncation\n\n  const tagList = [];\n  const textList = []; // Split it into two arrays, one of tags, one of texts.\n  // But keep positions intact, so we get:\n  // [ null, 'tag', null, 'tag', null, 'tag', null, 'tag', null ]\n  // [ 'text', null, 'text', null, 'text', null, 'text', null, 'text' ]\n\n  for (let i = 0; i < splitByTags.length; i++) {\n    if (splitByTags[i].slice(0, 1) === '<') {\n      tagList[i] = splitByTags[i];\n    } else {\n      textList[i] = splitByTags[i];\n    }\n  } // Now start reassembling, counting length of text parts only\n\n\n  let lengthSoFar = 0;\n  let out = '';\n  let overLimit = false;\n\n  for (let i = 0; i < splitByTags.length; i++) {\n    if (!overLimit) {\n      // We are still under the character limit.\n      // First deal with next bit of text\n      if (textList[i] && textList[i] !== '\\n') {\n        const textBitLength = textList[i].length;\n\n        if (lengthSoFar + textBitLength > limit) {\n          // OK so adding the current bit of text will take us over the limit.\n          // Work out by how much:\n          let truncBitLength = limit - lengthSoFar; // First, check here that we aren't about to chop an HTML entity in half.\n\n          const indexOfAmpersand = textList[i].indexOf('&');\n          const indexOfSemicolon = textList[i].indexOf(';');\n\n          if (indexOfAmpersand > -1 && indexOfSemicolon > -1 && indexOfAmpersand < truncBitLength && truncBitLength < indexOfSemicolon) {\n            truncBitLength = indexOfSemicolon;\n          } // and now chop the bit of text safely, add it to the output\n          // and signal we have reached the limit\n\n\n          const truncText = textList[i].slice(0, truncBitLength);\n          out += `${truncText.trim()}${endChar}`;\n          lengthSoFar += truncBitLength;\n          overLimit = true;\n        } else {\n          // otherwise, we aren't going over the limit by adding this\n          // bit so add it and update the cumulative length:\n          out += textList[i];\n          lengthSoFar += textBitLength;\n        }\n      } // Next add back in the next tag\n\n\n      if (tagList[i]) {\n        out += tagList[i]; // push them onto the stack, unless they self-closing\n\n        if (splitByTags[i].slice(-2) !== '/>') {\n          // or are the closing tag for the top of the stack\n          if (stack.length > 0 && generateClosingTag(stack[stack.length - 1]) === splitByTags[i]) {\n            stack.pop(); // its not the closing tag for the top of the stack, so\n            // if its not a 'rogue' closing tag, it will be an opening\n            // tag, so add it to the stack.\n          } else if (splitByTags[i].slice(0, 2) !== '</') {\n            stack.push(splitByTags[i]);\n          }\n        }\n      }\n    }\n  } // now add closing tags for any tags left in the stack\n\n\n  while (overLimit && stack.length > 0) {\n    const closing = generateClosingTag(stack.pop());\n\n    if (closing) {\n      out += closing;\n    }\n  }\n\n  return out;\n}\n\nfunction generateClosingTag(tag) {\n  // Writen by LukeD Apr/May 2020\n  // This function generates the closing\n  // tag that corresponds to any opening tag.\n  // EG </p> for a <p>, </div> for <div class=\"somthing\">\n  // or </ul> for <ul style=\"color: black\" class=\"someclass\">\n  if (!tag) {\n    // nothing to do...\n    return null;\n  }\n\n  if (tag.slice(0, 2) === '</') {\n    // it is already a closing tag!\n    return tag;\n  }\n\n  if (tag.slice(-2) === '/>') {\n    // its is a self-closing tag!\n    return tag;\n  } // match from after the < up until the first whitespace or the >\n\n\n  const inners = tag.match(/<([^\\s>]+).*/i);\n\n  if (inners[1]) {\n    return `</${inners[1]}>`;\n  }\n}\n\nTextTruncate.propTypes = {\n  className: PropTypes.string\n};\nexport default TextTruncate;","map":{"version":3,"sources":["/Users/luked/Documents/slnsw/dxlab-art-index/components/TextTruncate/TextTruncate.tsx"],"names":["React","PropTypes","isInViewport","css","TextTruncate","className","children","limit","ellipsisChars","showButton","shouldStripHtml","isActive","setActive","useState","useEffect","textTopMarkerEl","useRef","undefined","firstChildrenType","Array","isArray","props","dangerouslySetInnerHTML","__html","Children","only","text","map","child","childText","join","isTextOverLimit","stripHtml","length","result","strippedText","truncatedText","truncateNicely","newHtmlChild","cloneElement","button","current","scrollIntoView","replace","endChar","splitByTags","split","stack","tagList","textList","i","slice","lengthSoFar","out","overLimit","textBitLength","truncBitLength","indexOfAmpersand","indexOf","indexOfSemicolon","truncText","trim","generateClosingTag","pop","push","closing","tag","inners","match","propTypes","string"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\n// import Button from '../Button';\n\nimport { isInViewport } from '../../lib/is-in-viewport';\n// import { useUniqueId } from '../../lib/hooks';\n\nimport css from './TextTruncate.module.scss';\n\ntype Props = {\n  limit?: number;\n  children?: string | React.ReactNode;\n  className?: string;\n  ellipsisChars?: string;\n  showButton?: boolean;\n  shouldStripHtml?: boolean;\n  // onChange?: Function;\n};\n\n/**\n * Truncates text within props.children\n * Can accept multiple tags, strings or dangerouslySetInnerHTML\n * If using multiple tags, the first tag is used to display the truncated text.\n * Copied from CEP\n * TODO: Consider publishing as own component\n * TODO: Add tests from CEP\n */\nconst TextTruncate = ({\n  className,\n  children,\n  limit = 100,\n  ellipsisChars = '…',\n  showButton = true,\n  shouldStripHtml = false,\n  // onChange,\n}) => {\n  const [isActive, setActive] = React.useState(true);\n\n  React.useEffect(() => {\n    setActive(true);\n  }, [children]);\n\n  // const idScope = React.useRef(useUniqueId(`TextTruncate--`)).current;\n\n  const textTopMarkerEl = React.useRef(null);\n\n  if (children === undefined) {\n    return null;\n  }\n\n  // Work in progress\n  // if (typeof onChange === 'function') {\n  //   if (children.length > limit) {\n  //     onChange('more');\n  //   } else {\n  //     onChange('less');\n  //   }\n  // }\n\n  // Assign firstChildrenType\n  let firstChildrenType;\n\n  // Determine which initial element to use when truncate is active\n  if (typeof children === 'string') {\n    firstChildrenType = 'string';\n  } else if (Array.isArray(children)) {\n    if (\n      children[0].props.dangerouslySetInnerHTML &&\n      /* eslint-disable no-underscore-dangle */\n      children[0].props.dangerouslySetInnerHTML.__html\n    ) {\n      firstChildrenType = 'html';\n    } else {\n      firstChildrenType = 'tags';\n    }\n  } else if (React.Children.only(children)) {\n    if (\n      children.props.dangerouslySetInnerHTML &&\n      /* eslint-disable no-underscore-dangle */\n      children.props.dangerouslySetInnerHTML.__html\n      /* eslint-enable no-underscore-dangle */\n    ) {\n      firstChildrenType = 'html';\n    } else {\n      firstChildrenType = 'tag';\n    }\n  }\n\n  // Extract text\n  const text = React.Children.map(children, (child) => {\n    let childText;\n\n    if (typeof child === 'string') {\n      childText = child;\n    } else if (\n      child.props.dangerouslySetInnerHTML &&\n      /* eslint-disable no-underscore-dangle */\n      child.props.dangerouslySetInnerHTML.__html\n    ) {\n      childText = child.props.dangerouslySetInnerHTML.__html;\n      /* eslint-enable no-underscore-dangle */\n    } else {\n      childText = child.props.children;\n    }\n    return childText;\n  }).join(' ');\n\n  // Don't really want to count the HTML tags in the length\n  const isTextOverLimit = stripHtml(text).length > limit;\n\n  let result;\n\n  if (isTextOverLimit && isActive) {\n    const strippedText = shouldStripHtml ? stripHtml(text) : text;\n    // const truncatedText = `${strippedText\n    //   .slice(0, limit)\n    //   .trimRight()}${ellipsisChars}`;\n    const truncatedText = truncateNicely(strippedText, limit, ellipsisChars);\n\n    // Assign processed text depending on firstChildrenType\n    if (firstChildrenType === 'string') {\n      result = truncatedText;\n    } else if (firstChildrenType === 'html') {\n      const newHtmlChild = children.length > 0 ? children[0] : children;\n      result = React.cloneElement(\n        newHtmlChild,\n        shouldStripHtml\n          ? {\n              // dangerouslySetInnerHTML: {\n              //   __html: truncatedText,\n              // },\n              children: truncatedText,\n              dangerouslySetInnerHTML: undefined,\n            }\n          : {\n              dangerouslySetInnerHTML: {\n                __html: truncatedText,\n              },\n            },\n      );\n    } else if (firstChildrenType === 'tags') {\n      result = React.cloneElement(children[0], {\n        children: truncatedText,\n      });\n    } else if (firstChildrenType === 'tag') {\n      result = React.cloneElement(children, {\n        children: truncatedText,\n      });\n    }\n  } else {\n    result = children;\n  }\n\n  return (\n    <>\n      <span\n        // id={idScope}\n        ref={textTopMarkerEl}\n      />\n\n      {result}\n\n      {showButton && isTextOverLimit ? (\n        <button\n          className={[css.button, className].join(' ')}\n          data-testid=\"showMoreButton\"\n          aria-expanded={!isActive}\n          // aria-controls={idScope}\n          onClick={() => {\n            // Scroll back up to top of text if truncate is active and marker element is out of viewport\n            if (!isActive && !isInViewport(textTopMarkerEl.current)) {\n              textTopMarkerEl.current.scrollIntoView();\n            }\n            setActive(!isActive);\n          }}\n        >\n          {isActive ? 'Read more' : 'Read less'}\n        </button>\n      ) : null}\n    </>\n  );\n};\n\nfunction stripHtml(text) {\n  return text.replace(/(<([^>]+)>)/gi, '');\n}\n\nfunction truncateNicely(text, limit, endChar) {\n  // console.log(text);\n  // Writen by LukeD Apr/May 2020\n  // NOTE: uses generateClosingTag() function below.\n  // Function is passed a text string to be truncated to 'limit' chars long\n  // But it may contain nested HTML <tags> which we don't want to truncate in\n  // the middle of leaving this: <tag... (we also don't really want to count\n  // them as they don't generally contribute to the length of text rendered.)\n  // Also we want to ensure the correct closing tags exit after the truncation\n  // so the returned text is valid HTML.\n\n  const splitByTags = text.split(/(<[^>]+>)/gi);\n  // The above returns an array something like:\n  // [ 'text', 'tag', 'text', 'tag', 'text', 'tag', 'text', 'tag', 'text' ]\n\n  const stack = []; // place to remember opened tags that might need to closed after truncation\n  const tagList = [];\n  const textList = [];\n\n  // Split it into two arrays, one of tags, one of texts.\n  // But keep positions intact, so we get:\n  // [ null, 'tag', null, 'tag', null, 'tag', null, 'tag', null ]\n  // [ 'text', null, 'text', null, 'text', null, 'text', null, 'text' ]\n\n  for (let i = 0; i < splitByTags.length; i++) {\n    if (splitByTags[i].slice(0, 1) === '<') {\n      tagList[i] = splitByTags[i];\n    } else {\n      textList[i] = splitByTags[i];\n    }\n  }\n\n  // Now start reassembling, counting length of text parts only\n  let lengthSoFar = 0;\n  let out = '';\n  let overLimit = false;\n  for (let i = 0; i < splitByTags.length; i++) {\n    if (!overLimit) {\n      // We are still under the character limit.\n      // First deal with next bit of text\n      if (textList[i] && textList[i] !== '\\n') {\n        const textBitLength = textList[i].length;\n        if (lengthSoFar + textBitLength > limit) {\n          // OK so adding the current bit of text will take us over the limit.\n          // Work out by how much:\n          let truncBitLength = limit - lengthSoFar;\n          // First, check here that we aren't about to chop an HTML entity in half.\n          const indexOfAmpersand = textList[i].indexOf('&');\n          const indexOfSemicolon = textList[i].indexOf(';');\n          if (\n            indexOfAmpersand > -1 &&\n            indexOfSemicolon > -1 &&\n            indexOfAmpersand < truncBitLength &&\n            truncBitLength < indexOfSemicolon\n          ) {\n            truncBitLength = indexOfSemicolon;\n          }\n          // and now chop the bit of text safely, add it to the output\n          // and signal we have reached the limit\n          const truncText = textList[i].slice(0, truncBitLength);\n          out += `${truncText.trim()}${endChar}`;\n          lengthSoFar += truncBitLength;\n          overLimit = true;\n        } else {\n          // otherwise, we aren't going over the limit by adding this\n          // bit so add it and update the cumulative length:\n          out += textList[i];\n          lengthSoFar += textBitLength;\n        }\n      }\n      // Next add back in the next tag\n      if (tagList[i]) {\n        out += tagList[i];\n        // push them onto the stack, unless they self-closing\n        if (splitByTags[i].slice(-2) !== '/>') {\n          // or are the closing tag for the top of the stack\n          if (\n            stack.length > 0 &&\n            generateClosingTag(stack[stack.length - 1]) === splitByTags[i]\n          ) {\n            stack.pop();\n            // its not the closing tag for the top of the stack, so\n            // if its not a 'rogue' closing tag, it will be an opening\n            // tag, so add it to the stack.\n          } else if (splitByTags[i].slice(0, 2) !== '</') {\n            stack.push(splitByTags[i]);\n          }\n        }\n      }\n    }\n  }\n  // now add closing tags for any tags left in the stack\n  while (overLimit && stack.length > 0) {\n    const closing = generateClosingTag(stack.pop());\n    if (closing) {\n      out += closing;\n    }\n  }\n  return out;\n}\n\nfunction generateClosingTag(tag) {\n  // Writen by LukeD Apr/May 2020\n  // This function generates the closing\n  // tag that corresponds to any opening tag.\n  // EG </p> for a <p>, </div> for <div class=\"somthing\">\n  // or </ul> for <ul style=\"color: black\" class=\"someclass\">\n  if (!tag) {\n    // nothing to do...\n    return null;\n  }\n  if (tag.slice(0, 2) === '</') {\n    // it is already a closing tag!\n    return tag;\n  }\n  if (tag.slice(-2) === '/>') {\n    // its is a self-closing tag!\n    return tag;\n  }\n  // match from after the < up until the first whitespace or the >\n  const inners = tag.match(/<([^\\s>]+).*/i);\n  if (inners[1]) {\n    return `</${inners[1]}>`;\n  }\n}\n\nTextTruncate.propTypes = {\n  className: PropTypes.string,\n};\n\nexport default TextTruncate;\n"]},"metadata":{},"sourceType":"module"}