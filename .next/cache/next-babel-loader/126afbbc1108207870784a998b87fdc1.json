{"ast":null,"code":"import * as d3Array from 'd3-array';\nexport const arrayToCounts = a => {\n  if (!a) return null;\n  const counts = Object.create(null);\n  a.forEach(e => {\n    counts[e] = counts[e] ? counts[e] + 1 : 1;\n  });\n  const out = [];\n  Object.keys(counts).forEach(count => {\n    out.push({\n      item: count,\n      count: counts[count]\n    });\n  });\n  return out;\n};\nexport function getGenderColour(gender) {\n  if (gender === 'male') {\n    return 'var(--colour-art-index-male)';\n  }\n\n  if (gender === 'female') {\n    return 'var(--colour-art-index-female)';\n  }\n\n  return 'gray';\n}\nexport const processPriceData = input => {\n  const m = Array.from(d3Array.group(input, d => d['exhibitionYear'])).map(e => {\n    const year = e[0];\n    const withPrice = e[1].filter(p => p.price > 0);\n    const withPriceMale = withPrice.filter(p => p.artistGender === 'male'); // const withPriceFemale = withPrice.filter(\n    //   (p) => p.artistGender === 'female',\n    // );\n    // const avPrice = getAveragePrice(withPrice) || 0;\n\n    const avPriceMale = getAveragePrice(withPriceMale) || 0; // const avPriceFemale = getAveragePrice(withPriceFemale) || 0;\n\n    return {\n      name: year,\n      value: avPriceMale,\n      type: 'male'\n    };\n  }).sort((a, b) => {\n    const s = b.name < a.name ? 1 : 0;\n    return b.name > a.name ? -1 : s;\n  });\n  const f = Array.from(d3Array.group(input, d => d['exhibitionYear'])).map(e => {\n    const year = e[0];\n    const withPrice = e[1].filter(p => p.price > 0); // const withPriceMale = withPrice.filter(\n    //   (p) => p.artistGender === 'male',\n    // );\n\n    const withPriceFemale = withPrice.filter(p => p.artistGender === 'female'); // const avPrice = getAveragePrice(withPrice) || 0;\n    // const avPriceMale = getAveragePrice(withPriceMale) || 0;\n\n    const avPriceFemale = getAveragePrice(withPriceFemale) || 0;\n    return {\n      name: year,\n      value: avPriceFemale,\n      type: 'female'\n    };\n  }).sort((a, b) => {\n    const s = b.name < a.name ? 1 : 0;\n    return b.name > a.name ? -1 : s;\n  });\n  const t = [...f, ...m]; // console.log(t);\n\n  return t;\n};\n\nconst getAveragePrice = arr => {\n  if (!arr || arr.length === 0) {\n    return null;\n  }\n\n  const av = arr.reduce((total, next) => total + parseFloat(next.price), 0) / arr.length;\n  return Math.floor(av * 100) / 100;\n};\n\nexport const processFormatsByGenderData = input => {\n  const mout = Array.from(d3Array.group(input, d => d['mediumFormat'])).map(e => {\n    const format = e[0] || 'unknown';\n    const works = e[1].filter(f => f.artistGender === 'male');\n    return {\n      format,\n      works,\n      count: works.length\n    };\n  });\n  const fout = Array.from(d3Array.group(input, d => d['mediumFormat'])).map(e => {\n    const format = e[0] || 'unknown';\n    const works = e[1].filter(f => f.artistGender === 'female');\n    return {\n      format,\n      works,\n      count: works.length\n    };\n  });\n  const out = {\n    males: mout,\n    females: fout\n  };\n  return out;\n};\nexport const processFormatsByGenderToComparisonData = input => {\n  if (!input) {\n    return [];\n  }\n\n  const males = input.males || [];\n  const females = input.females || []; // // sort males\n  // males.sort((a, b) => {\n  //   const s = b.count > a.count ? 1 : 0;\n  //   return b.count < a.count ? -1 : s;\n  // });\n  // // arrange subset of data how we need\n  // const outm = males\n  //   ? males.slice(0, 40).map((d) => {\n  //       return { name: d.format, value: d.count, type: 'male' };\n  //     })\n  //   : [];\n  // // map female data to the subset of formats\n  // const outf =\n  //   females && outm\n  //     ? outm.map((d) => {\n  //         const foundf = females.filter((g) => {\n  //           return g.format === d.name;\n  //         });\n  //         return {\n  //           name: foundf[0].format,\n  //           value: foundf[0].count,\n  //           type: 'female',\n  //         };\n  //       })\n  //     : [];\n  // sort females\n\n  females.sort((a, b) => {\n    const s = b.count > a.count ? 1 : 0;\n    return b.count < a.count ? -1 : s;\n  }); // arrange subset of data how we need\n\n  const outf = females ? females.slice(0, 40).map(d => {\n    return {\n      name: d.format,\n      value: d.count,\n      type: 'female'\n    };\n  }) : []; // map male data to the subset of formats\n\n  const outm = males && outf ? outf.map(d => {\n    const foundm = males.filter(g => {\n      return g.format === d.name;\n    });\n    return {\n      name: foundm[0].format,\n      value: foundm[0].count,\n      type: 'male'\n    };\n  }) : [];\n  return [...outm, ...outf];\n};\nexport const processWorksByYear = input => {\n  var _data$, _data;\n\n  const data = Array.from(d3Array.group(input, d => d.exhibitionYear)).sort((a, b) => a[0] - b[0]).map(d => {\n    const year = d[0];\n    const allWorks = d[1];\n    return {\n      name: year,\n      value: allWorks.length,\n      malesTotal: allWorks.filter(work => work.artistGender === 'male').length,\n      femalesTotal: allWorks.filter(work => work.artistGender === 'female').length\n    };\n  });\n  const minYear = (_data$ = data[0]) === null || _data$ === void 0 ? void 0 : _data$.name;\n  const maxYear = (_data = data[data.length - 1]) === null || _data === void 0 ? void 0 : _data.name;\n  const out = [];\n\n  for (let y = minYear; y <= maxYear; y++) {\n    var _temp$, _temp$2, _temp$3;\n\n    const temp = data.filter(i => i.name === y.toString());\n    const val = ((_temp$ = temp[0]) === null || _temp$ === void 0 ? void 0 : _temp$.value) || 0;\n    const mval = ((_temp$2 = temp[0]) === null || _temp$2 === void 0 ? void 0 : _temp$2.malesTotal) || 0;\n    const fval = ((_temp$3 = temp[0]) === null || _temp$3 === void 0 ? void 0 : _temp$3.femalesTotal) || 0;\n    out.push({\n      name: y.toString(),\n      value: val,\n      malesTotal: mval,\n      femalesTotal: fval\n    });\n  }\n\n  return out;\n}; // export const processMapData = (input) => {\n//   const m = Array.from(d3Array.group(input, (d) => d['exhibitionPlace']))\n//     .map((val) => {\n//       let out = null;\n//       let lat;\n//       let long;\n//       if (val[0]) {\n//         const item = val[0];\n//         const itemData = geoData.filter((a) => a.address === item);\n//         if (itemData && itemData[0]) {\n//           [lat, long] = itemData[0].loc;\n//           out = {\n//             lat,\n//             long,\n//             count: val[1].length,\n//             item,\n//           };\n//         }\n//       }\n//       return out;\n//     })\n//     .filter((i) => i)\n//     .sort((a, b) => {\n//       const s = b.count < a.count ? 1 : 0;\n//       return b.count > a.count ? -1 : s;\n//     });\n//   return m;\n// };","map":{"version":3,"sources":["/Users/luked/Documents/slnsw/dxlab-art-index/lib/art-index-utils.ts"],"names":["d3Array","arrayToCounts","a","counts","Object","create","forEach","e","out","keys","count","push","item","getGenderColour","gender","processPriceData","input","m","Array","from","group","d","map","year","withPrice","filter","p","price","withPriceMale","artistGender","avPriceMale","getAveragePrice","name","value","type","sort","b","s","f","withPriceFemale","avPriceFemale","t","arr","length","av","reduce","total","next","parseFloat","Math","floor","processFormatsByGenderData","mout","format","works","fout","males","females","processFormatsByGenderToComparisonData","outf","slice","outm","foundm","g","processWorksByYear","data","exhibitionYear","allWorks","malesTotal","work","femalesTotal","minYear","maxYear","y","temp","i","toString","val","mval","fval"],"mappings":"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","sourcesContent":["import * as d3Array from 'd3-array';\n\nexport const arrayToCounts = (a) => {\n  if (!a) return null;\n  const counts = Object.create(null);\n  a.forEach((e) => {\n    counts[e] = counts[e] ? counts[e] + 1 : 1;\n  });\n  const out = [];\n  Object.keys(counts).forEach((count) => {\n    out.push({ item: count, count: counts[count] });\n  });\n  return out;\n};\n\nexport function getGenderColour(gender) {\n  if (gender === 'male') {\n    return 'var(--colour-art-index-male)';\n  }\n\n  if (gender === 'female') {\n    return 'var(--colour-art-index-female)';\n  }\n\n  return 'gray';\n}\n\nexport const processPriceData = (input) => {\n  const m = Array.from(d3Array.group(input, (d) => d['exhibitionYear']))\n    .map((e) => {\n      const year = e[0];\n      const withPrice = e[1].filter((p) => p.price > 0);\n      const withPriceMale = withPrice.filter((p) => p.artistGender === 'male');\n      // const withPriceFemale = withPrice.filter(\n      //   (p) => p.artistGender === 'female',\n      // );\n      // const avPrice = getAveragePrice(withPrice) || 0;\n      const avPriceMale = getAveragePrice(withPriceMale) || 0;\n      // const avPriceFemale = getAveragePrice(withPriceFemale) || 0;\n\n      return { name: year, value: avPriceMale, type: 'male' };\n    })\n    .sort((a, b) => {\n      const s = b.name < a.name ? 1 : 0;\n      return b.name > a.name ? -1 : s;\n    });\n  const f = Array.from(d3Array.group(input, (d) => d['exhibitionYear']))\n    .map((e) => {\n      const year = e[0];\n      const withPrice = e[1].filter((p) => p.price > 0);\n      // const withPriceMale = withPrice.filter(\n      //   (p) => p.artistGender === 'male',\n      // );\n      const withPriceFemale = withPrice.filter(\n        (p) => p.artistGender === 'female',\n      );\n      // const avPrice = getAveragePrice(withPrice) || 0;\n      // const avPriceMale = getAveragePrice(withPriceMale) || 0;\n      const avPriceFemale = getAveragePrice(withPriceFemale) || 0;\n\n      return { name: year, value: avPriceFemale, type: 'female' };\n    })\n    .sort((a, b) => {\n      const s = b.name < a.name ? 1 : 0;\n      return b.name > a.name ? -1 : s;\n    });\n  const t = [...f, ...m];\n  // console.log(t);\n  return t;\n};\n\nconst getAveragePrice = (arr) => {\n  if (!arr || arr.length === 0) {\n    return null;\n  }\n  const av =\n    arr.reduce((total, next) => total + parseFloat(next.price), 0) / arr.length;\n  return Math.floor(av * 100) / 100;\n};\n\nexport const processFormatsByGenderData = (input) => {\n  const mout = Array.from(d3Array.group(input, (d) => d['mediumFormat'])).map(\n    (e) => {\n      const format = e[0] || 'unknown';\n      const works = e[1].filter((f) => f.artistGender === 'male');\n      return { format, works, count: works.length };\n    },\n  );\n  const fout = Array.from(d3Array.group(input, (d) => d['mediumFormat'])).map(\n    (e) => {\n      const format = e[0] || 'unknown';\n      const works = e[1].filter((f) => f.artistGender === 'female');\n      return { format, works, count: works.length };\n    },\n  );\n  const out = { males: mout, females: fout };\n  return out;\n};\n\nexport const processFormatsByGenderToComparisonData = (input) => {\n  if (!input) {\n    return [];\n  }\n  const males = input.males || [];\n  const females = input.females || [];\n\n  // // sort males\n  // males.sort((a, b) => {\n  //   const s = b.count > a.count ? 1 : 0;\n  //   return b.count < a.count ? -1 : s;\n  // });\n  // // arrange subset of data how we need\n  // const outm = males\n  //   ? males.slice(0, 40).map((d) => {\n  //       return { name: d.format, value: d.count, type: 'male' };\n  //     })\n  //   : [];\n  // // map female data to the subset of formats\n  // const outf =\n  //   females && outm\n  //     ? outm.map((d) => {\n  //         const foundf = females.filter((g) => {\n  //           return g.format === d.name;\n  //         });\n\n  //         return {\n  //           name: foundf[0].format,\n  //           value: foundf[0].count,\n  //           type: 'female',\n  //         };\n  //       })\n  //     : [];\n\n  // sort females\n  females.sort((a, b) => {\n    const s = b.count > a.count ? 1 : 0;\n    return b.count < a.count ? -1 : s;\n  });\n  // arrange subset of data how we need\n  const outf = females\n    ? females.slice(0, 40).map((d) => {\n        return { name: d.format, value: d.count, type: 'female' };\n      })\n    : [];\n  // map male data to the subset of formats\n  const outm =\n    males && outf\n      ? outf.map((d) => {\n          const foundm = males.filter((g) => {\n            return g.format === d.name;\n          });\n\n          return {\n            name: foundm[0].format,\n            value: foundm[0].count,\n            type: 'male',\n          };\n        })\n      : [];\n\n  return [...outm, ...outf];\n};\n\nexport const processWorksByYear = (input) => {\n  const data = Array.from(d3Array.group(input, (d) => d.exhibitionYear))\n    .sort((a, b) => a[0] - b[0])\n    .map((d) => {\n      const year = d[0];\n      const allWorks = d[1];\n\n      return {\n        name: year,\n        value: allWorks.length,\n        malesTotal: allWorks.filter((work) => work.artistGender === 'male')\n          .length,\n        femalesTotal: allWorks.filter((work) => work.artistGender === 'female')\n          .length,\n      };\n    });\n  const minYear = data[0]?.name;\n  const maxYear = data[data.length - 1]?.name;\n  const out = [];\n  for (let y = minYear; y <= maxYear; y++) {\n    const temp = data.filter((i) => i.name === y.toString());\n    const val = temp[0]?.value || 0;\n    const mval = temp[0]?.malesTotal || 0;\n    const fval = temp[0]?.femalesTotal || 0;\n    out.push({\n      name: y.toString(),\n      value: val,\n      malesTotal: mval,\n      femalesTotal: fval,\n    });\n  }\n  return out;\n};\n\n// export const processMapData = (input) => {\n//   const m = Array.from(d3Array.group(input, (d) => d['exhibitionPlace']))\n//     .map((val) => {\n//       let out = null;\n//       let lat;\n//       let long;\n//       if (val[0]) {\n//         const item = val[0];\n//         const itemData = geoData.filter((a) => a.address === item);\n//         if (itemData && itemData[0]) {\n//           [lat, long] = itemData[0].loc;\n//           out = {\n//             lat,\n//             long,\n//             count: val[1].length,\n//             item,\n//           };\n//         }\n//       }\n//       return out;\n//     })\n//     .filter((i) => i)\n//     .sort((a, b) => {\n//       const s = b.count < a.count ? 1 : 0;\n//       return b.count > a.count ? -1 : s;\n//     });\n//   return m;\n// };\n"]},"metadata":{},"sourceType":"module"}