{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Flexible array flatten utility function\n */\nexport const flatten = (array, parentId = null, {\n  idField = 'id',\n  childrenField = 'children',\n  childrenTotalField = 'childrenTotal',\n  parentIdField = 'parentId'\n} = {}) => {\n  return array.reduce((acc, value) => {\n    const newValue = _objectSpread({}, value);\n\n    acc.push(newValue);\n\n    if (parentIdField) {\n      newValue[parentIdField] = parentId;\n      newValue[childrenTotalField] = newValue.children.length;\n    }\n\n    if (newValue.children) {\n      /* eslint-disable no-param-reassign */\n      acc = acc.concat(flatten(newValue[childrenField], newValue[idField], {\n        idField,\n        childrenField,\n        parentIdField\n      }));\n      /* eslint-enable no-param-reassign */\n\n      delete newValue.children;\n    } // console.log(acc);\n\n\n    return acc;\n  }, []);\n};\n/**\n * Transform flat records to hierarchy\n */\n\nexport const transformFlatToHierarchy = (flatRecords = [], id = null, count = 0) => {\n  if (flatRecords.length === 0) {\n    return [];\n  }\n\n  const rootRecord = flatRecords.find(record => record.parentId === id);\n  return [buildHierarchy(flatRecords, rootRecord, count)];\n};\n\nconst buildHierarchy = (flatRecords, record, count) => {\n  return _objectSpread(_objectSpread({}, record), {}, {\n    children: getChildren(flatRecords, record.id).map(r => {\n      return buildHierarchy(flatRecords, r, count + 1);\n    })\n  });\n};\n/**\n * Transform hierarchy records to lists\n */\n\n\nexport const transformHierarchyToLists = (records = [], id) => {\n  if (records.length === 0) {\n    return [];\n  }\n\n  if (!id) {\n    throw new Error('id argument required');\n  }\n\n  const flatRecords = flatten(records);\n  const lists = transformFlatToLists(flatRecords, id);\n  return lists;\n};\n/**\n * Transform flat records to lists\n */\n\nexport const transformFlatToLists = (flatRecords, id) => {\n  if (flatRecords.length === 0) {\n    return [];\n  }\n\n  if (!id) {\n    throw new Error('id argument required');\n  }\n\n  const lists = buildAncestorLists(flatRecords, id);\n  const children = getChildren(flatRecords, id);\n  const hasChildren = children && children.length > 0;\n  return [...lists, ...(hasChildren ? [children] : [])];\n};\n\nconst buildAncestorLists = (records, id, result = [], // TODO: Expose this to outer function\n{\n  selectedField = 'isSelected'\n} = {}) => {\n  const siblings = getSiblings(records, id);\n  const siblingsWithSelectedRecord = siblings.map(sibling => {\n    const isSelected = sibling.id === id;\n    return _objectSpread(_objectSpread({}, sibling), {}, {\n      [selectedField]: isSelected\n    });\n  });\n  const selectedItem = getItem(records, id);\n  const {\n    parentId\n  } = selectedItem;\n  const newResult = [siblingsWithSelectedRecord, ...result];\n\n  if (parentId) {\n    return buildAncestorLists(records, parentId, newResult, {\n      selectedField\n    });\n  }\n\n  return newResult;\n};\n\nconst getSiblings = (records, id) => {\n  const selectedItem = getItem(records, id);\n  return records.filter(item => {\n    return item.parentId === selectedItem.parentId;\n  });\n};\n\nconst getItem = (records, id) => {\n  return records.find(item => {\n    return item.id === id;\n  });\n};\n\nconst getChildren = (records, id) => {\n  return records.filter(item => {\n    return item.parentId === id;\n  });\n};","map":{"version":3,"sources":["/Users/luked/Documents/slnsw/dxlab-art-index/components/HierarchyColumnBrowser/hierarchyUtils.ts"],"names":["flatten","array","parentId","idField","childrenField","childrenTotalField","parentIdField","reduce","acc","value","newValue","push","children","length","concat","transformFlatToHierarchy","flatRecords","id","count","rootRecord","find","record","buildHierarchy","getChildren","map","r","transformHierarchyToLists","records","Error","lists","transformFlatToLists","buildAncestorLists","hasChildren","result","selectedField","siblings","getSiblings","siblingsWithSelectedRecord","sibling","isSelected","selectedItem","getItem","newResult","filter","item"],"mappings":";;;;;;AAAA;AACA;AACA;AACA,OAAO,MAAMA,OAAO,GAAG,CACrBC,KADqB,EAErBC,QAAQ,GAAG,IAFU,EAGrB;AACEC,EAAAA,OAAO,GAAG,IADZ;AAEEC,EAAAA,aAAa,GAAG,UAFlB;AAGEC,EAAAA,kBAAkB,GAAG,eAHvB;AAIEC,EAAAA,aAAa,GAAG;AAJlB,IAKI,EARiB,KASlB;AACH,SAAOL,KAAK,CAACM,MAAN,CAAa,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAClC,UAAMC,QAAQ,qBACTD,KADS,CAAd;;AAIAD,IAAAA,GAAG,CAACG,IAAJ,CAASD,QAAT;;AAEA,QAAIJ,aAAJ,EAAmB;AACjBI,MAAAA,QAAQ,CAACJ,aAAD,CAAR,GAA0BJ,QAA1B;AACAQ,MAAAA,QAAQ,CAACL,kBAAD,CAAR,GAA+BK,QAAQ,CAACE,QAAT,CAAkBC,MAAjD;AACD;;AAED,QAAIH,QAAQ,CAACE,QAAb,EAAuB;AACrB;AACAJ,MAAAA,GAAG,GAAGA,GAAG,CAACM,MAAJ,CACJd,OAAO,CAACU,QAAQ,CAACN,aAAD,CAAT,EAA0BM,QAAQ,CAACP,OAAD,CAAlC,EAA6C;AAClDA,QAAAA,OADkD;AAElDC,QAAAA,aAFkD;AAGlDE,QAAAA;AAHkD,OAA7C,CADH,CAAN;AAOA;;AACA,aAAOI,QAAQ,CAACE,QAAhB;AACD,KAvBiC,CAwBlC;;;AACA,WAAOJ,GAAP;AACD,GA1BM,EA0BJ,EA1BI,CAAP;AA2BD,CArCM;AAuCP;AACA;AACA;;AACA,OAAO,MAAMO,wBAAwB,GAAG,CACtCC,WAAW,GAAG,EADwB,EAEtCC,EAAE,GAAG,IAFiC,EAGtCC,KAAK,GAAG,CAH8B,KAInC;AACH,MAAIF,WAAW,CAACH,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAO,EAAP;AACD;;AAED,QAAMM,UAAU,GAAGH,WAAW,CAACI,IAAZ,CAAkBC,MAAD,IAAYA,MAAM,CAACnB,QAAP,KAAoBe,EAAjD,CAAnB;AAEA,SAAO,CAACK,cAAc,CAACN,WAAD,EAAcG,UAAd,EAA0BD,KAA1B,CAAf,CAAP;AACD,CAZM;;AAcP,MAAMI,cAAc,GAAG,CAACN,WAAD,EAAcK,MAAd,EAAsBH,KAAtB,KAAgC;AACrD,yCACKG,MADL;AAEET,IAAAA,QAAQ,EAAEW,WAAW,CAACP,WAAD,EAAcK,MAAM,CAACJ,EAArB,CAAX,CAAoCO,GAApC,CAAyCC,CAAD,IAAO;AACvD,aAAOH,cAAc,CAACN,WAAD,EAAcS,CAAd,EAAiBP,KAAK,GAAG,CAAzB,CAArB;AACD,KAFS;AAFZ;AAMD,CAPD;AASA;AACA;AACA;;;AACA,OAAO,MAAMQ,yBAAyB,GAAG,CAACC,OAAO,GAAG,EAAX,EAAeV,EAAf,KAA8B;AACrE,MAAIU,OAAO,CAACd,MAAR,KAAmB,CAAvB,EAA0B;AACxB,WAAO,EAAP;AACD;;AAED,MAAI,CAACI,EAAL,EAAS;AACP,UAAM,IAAIW,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,QAAMZ,WAAW,GAAGhB,OAAO,CAAC2B,OAAD,CAA3B;AACA,QAAME,KAAK,GAAGC,oBAAoB,CAACd,WAAD,EAAcC,EAAd,CAAlC;AAEA,SAAOY,KAAP;AACD,CAbM;AAeP;AACA;AACA;;AACA,OAAO,MAAMC,oBAAoB,GAAG,CAACd,WAAD,EAAcC,EAAd,KAA6B;AAC/D,MAAID,WAAW,CAACH,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAO,EAAP;AACD;;AAED,MAAI,CAACI,EAAL,EAAS;AACP,UAAM,IAAIW,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,QAAMC,KAAK,GAAGE,kBAAkB,CAACf,WAAD,EAAcC,EAAd,CAAhC;AACA,QAAML,QAAQ,GAAGW,WAAW,CAACP,WAAD,EAAcC,EAAd,CAA5B;AACA,QAAMe,WAAW,GAAGpB,QAAQ,IAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAlD;AAEA,SAAO,CAAC,GAAGgB,KAAJ,EAAW,IAAIG,WAAW,GAAG,CAACpB,QAAD,CAAH,GAAgB,EAA/B,CAAX,CAAP;AACD,CAdM;;AAgBP,MAAMmB,kBAAkB,GAAG,CACzBJ,OADyB,EAEzBV,EAFyB,EAGzBgB,MAAM,GAAG,EAHgB,EAIzB;AACA;AAAEC,EAAAA,aAAa,GAAG;AAAlB,IAAmC,EALV,KAMtB;AACH,QAAMC,QAAQ,GAAGC,WAAW,CAACT,OAAD,EAAUV,EAAV,CAA5B;AACA,QAAMoB,0BAA0B,GAAGF,QAAQ,CAACX,GAAT,CAAcc,OAAD,IAAa;AAC3D,UAAMC,UAAU,GAAGD,OAAO,CAACrB,EAAR,KAAeA,EAAlC;AAEA,2CACKqB,OADL;AAEE,OAACJ,aAAD,GAAiBK;AAFnB;AAID,GAPkC,CAAnC;AASA,QAAMC,YAAY,GAAGC,OAAO,CAACd,OAAD,EAAUV,EAAV,CAA5B;AACA,QAAM;AAAEf,IAAAA;AAAF,MAAesC,YAArB;AAEA,QAAME,SAAS,GAAG,CAACL,0BAAD,EAA6B,GAAGJ,MAAhC,CAAlB;;AAEA,MAAI/B,QAAJ,EAAc;AACZ,WAAO6B,kBAAkB,CAACJ,OAAD,EAAUzB,QAAV,EAAoBwC,SAApB,EAA+B;AACtDR,MAAAA;AADsD,KAA/B,CAAzB;AAGD;;AAED,SAAOQ,SAAP;AACD,CA7BD;;AA+BA,MAAMN,WAAW,GAAG,CAACT,OAAD,EAAUV,EAAV,KAAiB;AACnC,QAAMuB,YAAY,GAAGC,OAAO,CAACd,OAAD,EAAUV,EAAV,CAA5B;AAEA,SAAOU,OAAO,CAACgB,MAAR,CAAgBC,IAAD,IAAU;AAC9B,WAAOA,IAAI,CAAC1C,QAAL,KAAkBsC,YAAY,CAACtC,QAAtC;AACD,GAFM,CAAP;AAGD,CAND;;AAQA,MAAMuC,OAAO,GAAG,CAACd,OAAD,EAAUV,EAAV,KAAiB;AAC/B,SAAOU,OAAO,CAACP,IAAR,CAAcwB,IAAD,IAAU;AAC5B,WAAOA,IAAI,CAAC3B,EAAL,KAAYA,EAAnB;AACD,GAFM,CAAP;AAGD,CAJD;;AAMA,MAAMM,WAAW,GAAG,CAACI,OAAD,EAAUV,EAAV,KAAiB;AACnC,SAAOU,OAAO,CAACgB,MAAR,CAAgBC,IAAD,IAAU;AAC9B,WAAOA,IAAI,CAAC1C,QAAL,KAAkBe,EAAzB;AACD,GAFM,CAAP;AAGD,CAJD","sourcesContent":["/**\n * Flexible array flatten utility function\n */\nexport const flatten = (\n  array,\n  parentId = null,\n  {\n    idField = 'id',\n    childrenField = 'children',\n    childrenTotalField = 'childrenTotal',\n    parentIdField = 'parentId',\n  } = {},\n) => {\n  return array.reduce((acc, value) => {\n    const newValue = {\n      ...value,\n    };\n\n    acc.push(newValue);\n\n    if (parentIdField) {\n      newValue[parentIdField] = parentId;\n      newValue[childrenTotalField] = newValue.children.length;\n    }\n\n    if (newValue.children) {\n      /* eslint-disable no-param-reassign */\n      acc = acc.concat(\n        flatten(newValue[childrenField], newValue[idField], {\n          idField,\n          childrenField,\n          parentIdField,\n        }),\n      );\n      /* eslint-enable no-param-reassign */\n      delete newValue.children;\n    }\n    // console.log(acc);\n    return acc;\n  }, []);\n};\n\n/**\n * Transform flat records to hierarchy\n */\nexport const transformFlatToHierarchy = (\n  flatRecords = [],\n  id = null,\n  count = 0,\n) => {\n  if (flatRecords.length === 0) {\n    return [];\n  }\n\n  const rootRecord = flatRecords.find((record) => record.parentId === id);\n\n  return [buildHierarchy(flatRecords, rootRecord, count)];\n};\n\nconst buildHierarchy = (flatRecords, record, count) => {\n  return {\n    ...record,\n    children: getChildren(flatRecords, record.id).map((r) => {\n      return buildHierarchy(flatRecords, r, count + 1);\n    }),\n  };\n};\n\n/**\n * Transform hierarchy records to lists\n */\nexport const transformHierarchyToLists = (records = [], id: string) => {\n  if (records.length === 0) {\n    return [];\n  }\n\n  if (!id) {\n    throw new Error('id argument required');\n  }\n\n  const flatRecords = flatten(records);\n  const lists = transformFlatToLists(flatRecords, id);\n\n  return lists;\n};\n\n/**\n * Transform flat records to lists\n */\nexport const transformFlatToLists = (flatRecords, id: string) => {\n  if (flatRecords.length === 0) {\n    return [];\n  }\n\n  if (!id) {\n    throw new Error('id argument required');\n  }\n\n  const lists = buildAncestorLists(flatRecords, id);\n  const children = getChildren(flatRecords, id);\n  const hasChildren = children && children.length > 0;\n\n  return [...lists, ...(hasChildren ? [children] : [])];\n};\n\nconst buildAncestorLists = (\n  records,\n  id,\n  result = [],\n  // TODO: Expose this to outer function\n  { selectedField = 'isSelected' } = {},\n) => {\n  const siblings = getSiblings(records, id);\n  const siblingsWithSelectedRecord = siblings.map((sibling) => {\n    const isSelected = sibling.id === id;\n\n    return {\n      ...sibling,\n      [selectedField]: isSelected,\n    };\n  });\n\n  const selectedItem = getItem(records, id);\n  const { parentId } = selectedItem;\n\n  const newResult = [siblingsWithSelectedRecord, ...result];\n\n  if (parentId) {\n    return buildAncestorLists(records, parentId, newResult, {\n      selectedField,\n    });\n  }\n\n  return newResult;\n};\n\nconst getSiblings = (records, id) => {\n  const selectedItem = getItem(records, id);\n\n  return records.filter((item) => {\n    return item.parentId === selectedItem.parentId;\n  });\n};\n\nconst getItem = (records, id) => {\n  return records.find((item) => {\n    return item.id === id;\n  });\n};\n\nconst getChildren = (records, id) => {\n  return records.filter((item) => {\n    return item.parentId === id;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}